# Добавление функции суммаризации YouTube видео в существующий Telegram бот с Groq API

## Задача
Добавить в существующий Telegram бот (который уже использует Groq API) функциональность автоматической суммаризации YouTube видео через yt-dlp + open-source Whisper + Groq API.

## 1. Дополнительные зависимости

Добавь в requirements.txt:
```
yt-dlp>=2023.7.6
openai-whisper>=20231117
torch>=2.0.0
torchaudio>=2.0.0
pydub>=0.25.1
validators>=0.22.0
```

## 2. Основные функции

### Функция 1: Определение YouTube URL
```python
import re
import validators

def extract_youtube_urls(text):
    """Извлекает YouTube URL из текста сообщения"""
    youtube_patterns = [
        r'(?:https?://)?(?:www\.)?youtube\.com/watch\?v=([a-zA-Z0-9_-]+)',
        r'(?:https?://)?(?:www\.)?youtu\.be/([a-zA-Z0-9_-]+)',
        r'(?:https?://)?(?:www\.)?youtube\.com/embed/([a-zA-Z0-9_-]+)',
        r'(?:https?://)?(?:www\.)?youtube\.com/v/([a-zA-Z0-9_-]+)'
    ]
    
    youtube_urls = []
    for pattern in youtube_patterns:
        matches = re.finditer(pattern, text)
        for match in matches:
            video_id = match.group(1)
            full_url = f"https://www.youtube.com/watch?v={video_id}"
            youtube_urls.append({
                'url': full_url,
                'video_id': video_id,
                'original_url': match.group(0)
            })
    
    return youtube_urls

def validate_youtube_url(url):
    """Проверяет доступность YouTube видео"""
    try:
        import yt_dlp
        
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            
            duration = info.get('duration', 0)
            if duration > 3600:  # 1 час максимум
                return {
                    'valid': False,
                    'error': 'Видео слишком длинное (более 1 часа)'
                }
            
            if info.get('is_live'):
                return {
                    'valid': False,
                    'error': 'Прямые трансляции не поддерживаются'
                }
            
            return {
                'valid': True,
                'title': info.get('title', 'Без названия'),
                'duration': duration,
                'uploader': info.get('uploader', 'Неизвестно'),
                'view_count': info.get('view_count', 0)
            }
            
    except Exception as e:
        return {
            'valid': False,
            'error': f'Ошибка при проверке видео: {str(e)}'
        }
```

### Функция 2: Извлечение аудио из YouTube
```python
import yt_dlp
import os
import tempfile

def extract_audio_from_youtube(url, max_duration=3600):
    """Извлекает аудиодорожку из YouTube видео"""
    try:
        temp_dir = tempfile.mkdtemp()
        
        ydl_opts = {
            'format': 'bestaudio/best',
            'outtmpl': os.path.join(temp_dir, '%(title)s.%(ext)s'),
            'extractaudio': True,
            'audioformat': 'wav',
            'audioquality': '0',
            'quiet': True,
            'no_warnings': True,
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'wav',
                'preferredquality': '0',
            }],
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            
            duration = info.get('duration', 0)
            if duration > max_duration:
                raise Exception(f"Видео слишком длинное: {duration//60} минут")
            
            ydl.download([url])
            
            for file in os.listdir(temp_dir):
                if file.endswith('.wav'):
                    audio_path = os.path.join(temp_dir, file)
                    
                    return {
                        'success': True,
                        'audio_path': audio_path,
                        'title': info.get('title', 'Без названия'),
                        'duration': duration,
                        'uploader': info.get('uploader', 'Неизвестно'),
                        'temp_dir': temp_dir
                    }
        
        raise Exception("Не удалось найти аудио файл")
        
    except Exception as e:
        return {
            'success': False,
            'error': f'Ошибка при извлечении аудио: {str(e)}'
        }
```

### Функция 3: Транскрибация через open-source Whisper
```python
import whisper
import torch

# Глобальная переменная для модели Whisper
whisper_model = None

def load_whisper_model():
    """Загружает Whisper модель при первом использовании"""
    global whisper_model
    if whisper_model is None:
        try:
            # Используем base модель для баланса скорости и качества
            whisper_model = whisper.load_model("base")
            print("Whisper модель 'base' загружена успешно")
        except Exception as e:
            print(f"Ошибка загрузки Whisper: {e}")
            # Fallback на самую маленькую модель
            whisper_model = whisper.load_model("tiny")
            
    return whisper_model

def transcribe_audio_whisper(audio_path, language='auto'):
    """Транскрибирует аудио через open-source Whisper"""
    try:
        model = load_whisper_model()
        if model is None:
            return {
                'success': False,
                'error': 'Не удалось загрузить модель Whisper'
            }
        
        options = {
            'language': None if language == 'auto' else language,
            'task': 'transcribe',
            'fp16': False  # Для совместимости
        }
        
        print(f"Начинаю транскрибацию файла: {audio_path}")
        result = model.transcribe(audio_path, **options)
        
        return {
            'success': True,
            'text': result['text'],
            'language': result.get('language', 'unknown')
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f'Ошибка транскрибации: {str(e)}'
        }

def split_audio_for_whisper(audio_path, max_duration_minutes=20):
    """Разбивает длинное аудио на части"""
    try:
        from pydub import AudioSegment
        
        audio = AudioSegment.from_wav(audio_path)
        duration_ms = len(audio)
        
        # Если аудио короткое, не разбиваем
        if duration_ms < max_duration_minutes * 60 * 1000:
            return [audio_path]
        
        # Разбиваем на части
        chunk_length_ms = max_duration_minutes * 60 * 1000
        chunks = []
        
        for i in range(0, duration_ms, chunk_length_ms):
            chunk = audio[i:i + chunk_length_ms]
            chunk_path = audio_path.replace('.wav', f'_part_{i//chunk_length_ms + 1}.wav')
            chunk.export(chunk_path, format="wav")
            chunks.append(chunk_path)
        
        return chunks
        
    except Exception as e:
        print(f"Ошибка разбивки аудио: {e}")
        return [audio_path]

def transcribe_long_audio(audio_path):
    """Транскрибирует длинное аудио по частям"""
    chunks = split_audio_for_whisper(audio_path)
    full_transcript = ""
    
    for i, chunk_path in enumerate(chunks):
        print(f"Обрабатываю часть {i+1}/{len(chunks)}")
        
        result = transcribe_audio_whisper(chunk_path)
        if result['success']:
            if i > 0:
                full_transcript += f"\n\n--- Часть {i+1} ---\n"
            full_transcript += result['text']
        else:
            print(f"Ошибка в части {i+1}: {result['error']}")
        
        # Удаляем временный файл части
        if chunk_path != audio_path:
            try:
                os.remove(chunk_path)
            except:
                pass
    
    return {
        'success': True if full_transcript else False,
        'text': full_transcript,
        'parts_count': len(chunks)
    }
```

### Функция 4: Суммаризация через Groq (используем существующую настройку)
```python
from groq import Groq
import os

def summarize_youtube_transcript(transcript, video_title="", video_duration=0):
    """Создает резюме транскрипта YouTube видео через Groq API"""
    try:
        client = Groq(api_key=os.getenv("GROQ_API_KEY"))
        
        # Ограничиваем длину транскрипта
        max_chars = 10000
        if len(transcript) > max_chars:
            transcript = transcript[:max_chars] + "...\n[Транскрипт обрезан для обработки]"
        
        # Определяем длину резюме
        if video_duration < 600:  # Менее 10 минут
            summary_length = "150-250 слов"
            max_tokens = 300
        elif video_duration < 1800:  # Менее 30 минут
            summary_length = "250-400 слов"
            max_tokens = 450
        else:  # Более 30 минут
            summary_length = "400-600 слов"
            max_tokens = 600
        
        duration_str = f"{video_duration//60} минут {video_duration%60} секунд"
        
        prompt = f"""Создай структурированное резюме YouTube видео на русском языке.

ИНФОРМАЦИЯ О ВИДЕО:
Название: {video_title}
Длительность: {duration_str}

ТРЕБОВАНИЯ К РЕЗЮМЕ:
- Объем: {summary_length}
- Структура: основная тема, ключевые моменты, главные выводы
- Используй маркированные списки для ключевых идей
- Сохрани важные факты, цифры, имена
- Пиши понятным и структурированным языком

ТРАНСКРИПТ ВИДЕО:
{transcript}

СТРУКТУРИРОВАННОЕ РЕЗЮМЕ:"""

        completion = client.chat.completions.create(
            messages=[
                {
                    "role": "system", 
                    "content": "Ты эксперт по созданию качественных резюме видеоконтента. Создавай четкие, информативные и полезные саммари на русском языке."
                },
                {
                    "role": "user", 
                    "content": prompt
                }
            ],
            model="llama3-8b-8192",
            max_tokens=max_tokens,
            temperature=0.3
        )
        
        summary = completion.choices[0].message.content.strip()
        
        return {
            'success': True,
            'summary': summary
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f'Ошибка суммаризации Groq: {str(e)}'
        }

def create_fallback_summary(transcript, video_title=""):
    """Простое резюме без AI как запасной вариант"""
    try:
        sentences = transcript.split('.')
        sentences = [s.strip() for s in sentences if len(s.strip()) > 30]
        
        # Берем ключевые предложения
        summary_sentences = []
        if len(sentences) > 0:
            summary_sentences.append(sentences[0])  # Начало
        if len(sentences) > 4:
            summary_sentences.append(sentences[len(sentences)//3])  # Треть
            summary_sentences.append(sentences[2*len(sentences)//3])  # Две трети
        if len(sentences) > 1:
            summary_sentences.append(sentences[-1])  # Конец
        
        summary = '. '.join(summary_sentences)
        
        if len(summary) > 1000:
            summary = summary[:1000] + "..."
        
        summary += "\n\n⚠️ Автоматическое извлечение (AI суммаризация недоступна)"
        
        return {
            'success': True,
            'summary': summary
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': f'Ошибка fallback резюме: {e}'
        }
```

## 3. Основной обработчик для интеграции с ботом

```python
import asyncio
import shutil

async def handle_youtube_video(update, context):
    """Главный обработчик YouTube ссылок"""
    message_text = update.message.text
    chat_id = update.message.chat_id
    
    # Извлекаем YouTube URL
    youtube_urls = extract_youtube_urls(message_text)
    
    if not youtube_urls:
        return  # Если YouTube URL нет, обработчик не срабатывает
    
    # Ограничиваем количество видео
    if len(youtube_urls) > 1:
        await context.bot.send_message(
            chat_id=chat_id,
            text="⚠️ Обрабатываю только первое видео из списка."
        )
        youtube_urls = youtube_urls[:1]
    
    for url_info in youtube_urls:
        url = url_info['url']
        
        # Начальное сообщение
        processing_msg = await context.bot.send_message(
            chat_id=chat_id,
            text="🎥 Начинаю обработку YouTube видео...\n⏳ Процесс займет 3-8 минут в зависимости от длительности."
        )
        
        try:
            # Этап 1: Проверка видео
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=processing_msg.message_id,
                text="🔍 Проверяю доступность и параметры видео..."
            )
            
            validation = validate_youtube_url(url)
            if not validation['valid']:
                await context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=processing_msg.message_id,
                    text=f"❌ {validation['error']}"
                )
                continue
            
            video_title = validation['title']
            video_duration = validation['duration']
            video_uploader = validation['uploader']
            
            # Этап 2: Извлечение аудио
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=processing_msg.message_id,
                text=f"🎵 Извлекаю аудиодорожку...\n📹 {video_title[:60]}..."
            )
            
            audio_result = extract_audio_from_youtube(url)
            if not audio_result['success']:
                await context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=processing_msg.message_id,
                    text=f"❌ Ошибка извлечения аудио: {audio_result['error']}"
                )
                continue
            
            # Этап 3: Транскрибация
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=processing_msg.message_id,
                text="🎤 Преобразую речь в текст (Whisper AI)...\nЭто самый долгий этап: 3-6 минут."
            )
            
            # Выбираем метод в зависимости от длительности
            if video_duration > 1200:  # Более 20 минут
                transcript_result = transcribe_long_audio(audio_result['audio_path'])
            else:
                transcript_result = transcribe_audio_whisper(audio_result['audio_path'])
            
            if not transcript_result['success']:
                await context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=processing_msg.message_id,
                    text=f"❌ Ошибка транскрибации: {transcript_result['error']}"
                )
                continue
            
            # Этап 4: Создание резюме
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=processing_msg.message_id,
                text="📝 Создаю структурированное резюме (Groq AI)..."
            )
            
            summary_result = summarize_youtube_transcript(
                transcript_result['text'],
                video_title,
                video_duration
            )
            
            if not summary_result['success']:
                # Fallback на простое резюме
                summary_result = create_fallback_summary(
                    transcript_result['text'],
                    video_title
                )
            
            if not summary_result['success']:
                summary_text = "❌ Не удалось создать резюме"
            else:
                summary_text = summary_result['summary']
            
            # Формируем финальный ответ
            duration_str = f"{video_duration//60}:{video_duration%60:02d}"
            transcript_length = len(transcript_result['text'])
            
            response = f"""🎥 **Резюме YouTube видео**

📺 **Название:** {video_title}
👤 **Автор:** {video_uploader}
⏱️ **Длительность:** {duration_str}
🔗 **Ссылка:** {url}

📋 **Резюме содержания:**
{summary_text}

📊 **Статистика обработки:**
• Транскрипт: {transcript_length:,} символов
• Метод: Whisper + Groq (Llama3)
• Время обработки: ~{max(3, video_duration//60 + 2)} минут"""

            # Отправляем результат
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=processing_msg.message_id,
                text=response,
                parse_mode='Markdown',
                disable_web_page_preview=True
            )
            
        except Exception as e:
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=processing_msg.message_id,
                text=f"❌ Произошла неожиданная ошибка: {str(e)}"
            )
        
        finally:
            # Обязательная очистка временных файлов
            try:
                if 'audio_result' in locals() and audio_result.get('success'):
                    temp_dir = audio_result.get('temp_dir')
                    if temp_dir and os.path.exists(temp_dir):
                        shutil.rmtree(temp_dir)
                        print(f"Очищена временная директория: {temp_dir}")
            except Exception as cleanup_error:
                print(f"Ошибка очистки: {cleanup_error}")
```

## 4. Регистрация обработчика в боте

```python
# В главном файле бота добавь этот обработчик к существующим
from telegram.ext import MessageHandler, filters

# Обработчик YouTube ссылок (добавить с высоким приоритетом)
application.add_handler(MessageHandler(
    filters.TEXT & (
        filters.Regex(r'youtube\.com/watch') |
        filters.Regex(r'youtu\.be/') |
        filters.Regex(r'youtube\.com/embed/') |
        filters.Regex(r'youtube\.com/v/')
    ),
    handle_youtube_video
))
```

## 5. Команда справки (опционально)

```python
async def youtube_help_command(update, context):
    """Справка по суммаризации YouTube"""
    help_text = """🎥 **Суммаризация YouTube видео**

**Как использовать:**
Просто отправьте ссылку на YouTube видео, и бот создаст подробное резюме содержания.

**Поддерживаемые форматы:**
• youtube.com/watch?v=...
• youtu.be/...
• youtube.com/embed/...

**Технические ограничения:**
• Максимальная длительность: 1 час
• Закрытые/приватные видео недоступны
• Прямые трансляции не поддерживаются

**Процесс обработки:**
1. 🔍 Проверка доступности (10 сек)
2. 🎵 Извлечение аудио (30-60 сек)
3. 🎤 Транскрибация речи (3-6 мин)
4. 📝 Создание резюме (30 сек)

**Время обработки:** 3-8 минут

**Технологии:**
• yt-dlp для извлечения аудио
• Whisper AI для транскрибации
• Groq (Llama3) для суммаризации"""

    await update.message.reply_text(help_text, parse_mode='Markdown')

# Регистрация команды справки
application.add_handler(CommandHandler("youtube", youtube_help_command))
```

## 6. Проверка готовности к запуску

### Убедись, что в .env есть:
```
GROQ_API_KEY=your_existing_groq_key
```

### Проверь системные требования:
- FFmpeg установлен (обычно есть в Replit)
- Достаточно оперативной памяти для Whisper
- Stable интернет для скачивания видео

## 7. Тестирование

### Рекомендуемые тесты:
1. **Короткое видео (2-5 мин)** - для проверки базовой функциональности
2. **Среднее видео (15-20 мин)** - для проверки разбивки на части
3. **Длинное видео (45-60 мин)** - для проверки лимитов
4. **Разные языки** - русский, английский
5. **Разные типы контента** - лекции, интервью, новости

### Ожидаемые результаты:
- Время обработки: 3-8 минут
- Качество транскрипции: 85-95% точность
- Качество резюме: структурированное, информативное
- Стабильность: без падений при обработке

---

**Готово к использованию!** Этот код интегрируется в твой существующий бот с минимальными изменениями и использует уже настроенный Groq API.