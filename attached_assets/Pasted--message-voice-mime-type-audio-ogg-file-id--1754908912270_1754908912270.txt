
Симптомы из логов
	•	Приходит message.voice (mime_type=audio/ogg, есть file_id).
	•	Бот отправляет заглушку («Отправка сообщения…»), но дальше ничего не делает: нет логов скачивания/конвертации/ASR.
	•	offset обновляется сразу после отправки заглушки.

Задачи
	1.	Обновить обработчик handle_update/основной цикл так, чтобы до обновления offset происходила полная обработка аудио (скачивание → ffmpeg → ASR → саммари → edit).
	2.	Явно маршрутизировать message.voice, message.audio, message.document (audio/*), message.video_note в единый аудио‑пайплайн.
	3.	В SimpleTelegramBot убедиться, что есть методы get_file, download_file, edit_message_text.
	4.	Добавить подробные логи в ключевые точки и явную проверку ffmpeg.

Изменения (минимально инвазивно)

1) Главный цикл/handle_update — синхронная обработка до обновления offset
	•	В месте, где мы делаем GET_UPDATES и затем Обновлен offset, перенести обновление offset на ПОСЛЕ успешного завершения handle_update(update).
	•	Внутри handle_update(update):
	•	Если это текст → текущая логика.
	•	Если найден аудиовложение → вызвать audio_pipeline.handler.handle_audio_message(bot, message) и дождаться завершения (без фоновых потоков/таймеров).
	•	Добавить логи: ROUTE audio -> start, downloaded path=…, ffmpeg ok, ASR ok, summary ok.

2) Единое извлечение аудио

Файл: audio_pipeline/handler.py (или utils)

def extract_audio_file_id_and_kind(message):
    if getattr(message, "voice", None):
        return message.voice.file_id, "voice"
    if getattr(message, "audio", None):
        return message.audio.file_id, "audio"
    doc = getattr(message, "document", None)
    if doc and (doc.mime_type or "").startswith("audio/"):
        return doc.file_id, "document-audio"
    if getattr(message, "video_note", None):
        return message.video_note.file_id, "video_note"
    return None, None

3) Универсальный хендлер аудио

Файл: audio_pipeline/handler.py

import os, time, traceback
from audio_pipeline import downloader, transcriber, segmenter
from utils import ffmpeg
from summarization_adapter import run_summarization

def handle_audio_message(bot, message, workdir="/tmp"):
    file_id, kind = extract_audio_file_id_and_kind(message)
    if not file_id:
        return False  # не аудио — пусть дальше обработает текстовый путь

    chat_id = message.chat.id
    placeholder = bot.send_message(chat_id, "Получил аудио, обрабатываю…")
    status_msg_id = placeholder["message_id"]
    t0 = time.time()

    raw_path = wav_path = None
    try:
        os.makedirs(workdir, exist_ok=True)
        # 1) скачать
        raw_path = downloader.download_audio(bot, file_id, workdir)
        bot_log(f"download ok: {raw_path}")

        # 2) нормализовать в wav 16k mono
        wav_path = os.path.join(workdir, f"norm_{int(time.time())}.wav")
        ffmpeg.to_wav_16k_mono(raw_path, wav_path)
        bot_log(f"ffmpeg ok: {wav_path}")

        # 3) (опц.) чанкинг длинных
        # if duration > threshold: chunks = segmenter.segment_audio(wav_path, ...)
        # else:
        chunks = [wav_path]

        # 4) ASR
        asr = transcriber.transcribe_audio(chunks[0])
        bot_log(f"asr ok: engine={asr.get('engine')} lang={asr.get('language')}")

        # 5) саммари
        summary = run_summarization(asr["text"], language_hint=asr.get("language"))
        total = time.time() - t0
        final_text = (
            f"Саммари аудио (движок: {asr.get('engine')}, язык: {asr.get('language')}, время: {total:.1f}s)\n\n"
            + summary
        )

        bot.edit_message_text(chat_id, status_msg_id, final_text)
        # 6) приложить txt с полной транскрипцией (по желанию)
        # bot.send_document(chat_id, file=BytesIO(full_text.encode('utf-8')), filename="transcript.txt")
        return True

    except Exception as e:
        err = f"Ошибка обработки аудио: {e.__class__.__name__}: {e}"
        bot_log(err)
        bot_log(traceback.format_exc())
        try:
            bot.edit_message_text(chat_id, status_msg_id, err)
        except Exception:
            pass
        return True  # считаем обработанным, чтобы не зациклить

    finally:
        for p in (raw_path, wav_path):
            if p and os.path.exists(p):
                try: os.remove(p)
                except: pass

В handle_update вызывать handled = handle_audio_message(bot, message). Если handled — не запускай текстовый путь для этого апдейта.

4) Downloader — использовать Telegram getFile/file download

Файл: audio_pipeline/downloader.py

import os, datetime

def download_audio(bot, file_id: str, out_dir: str) -> str:
    os.makedirs(out_dir, exist_ok=True)
    stamp = datetime.datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    dst = os.path.join(out_dir, f"tg_{stamp}_{file_id}.bin")
    return bot.download_file(file_id, dst)

5) SimpleTelegramBot — методы и ffmpeg‑проверка

Файл: simple_telegram_bot.py
	•	Убедиться, что есть:
	•	get_file(file_id) -> dict (Telegram getFile)
	•	download_file(file_id, dst_path) -> str
	•	edit_message_text(chat_id, message_id, text, parse_mode=None)
	•	На старте приложения (main) добавить:

import shutil, os, logging
_ff = os.getenv("FFMPEG_PATH", "ffmpeg")
assert shutil.which(_ff), "ffmpeg not found"
logging.info(f"FFMPEG OK at: {shutil.which(_ff)}")

6) Логика обновления offset
	•	В месте, где сейчас сразу после отправки заглушки пишется «Обновлен offset», изменить порядок:
	•	handle_update(update) полностью выполняется (включая аудио).
	•	Только после успешного возврата → offset = update_id + 1 и лог «Обновлен offset».
	•	Добавить лог‑маячки:
	•	ROUTE audio -> start
	•	download ok, ffmpeg ok, asr ok, summary ok
	•	ROUTE audio -> done (X.Y s)

7) ENV

Убедиться, что на Railway выставлено:

AUDIO_SUMMARY_ENABLED=true
ASR_ENGINE=vosk
FFMPEG_PATH=ffmpeg
ASR_MAX_DURATION_MIN=20

8) requirements (минимум для запуска)

requests
vosk==0.3.45
pydub
soundfile
librosa

(HF/SpeechBrain добавить позже — лениво грузить и с фоллбэком на Vosk.)

Acceptance Criteria
	•	На voice (audio/ogg, 3–5 сек) бот логирует: ROUTE audio -> start → скачал файл → ffmpeg ok → asr ok → редактирует заглушку на итог.
	•	Offset обновляется после завершения обработки, а не до.
	•	Нет падений по get_file/edit_message_text.
	•	В логах есть путь скачанного файла и подтверждение наличия ffmpeg.
